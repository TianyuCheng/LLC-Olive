%term DUMMY=0
%term Ret=1 Br=2 Switch=3 IndirectBr=4 Invoke=5 Resume=6 Unreachable=7 CleanupRet=8 CatchRet=9 CatchSwitch=10
%term Add=11 FAdd=12 Sub=13 FSub=14 Mul=15 FMul=16 UDiv=17 SDiv=18 FDiv=19 URem=20 SRem=21 FRem=22
%term Shl=23 LShr=24 AShr=25 And=26 Or=27 Xor=28
%term Alloca=29 Load=30 Store=31 GetElementPtr=32 Fence=33 AtomicCmpXchg=34 AtomicRMW=35
%term Trunc=36 ZExt=37 SExt=38 FPToUI=39 FPToSI=40 UIToFP=41 SIToFP=42 FPTrunc=43 FPExt=44 PtrToInt=45 IntToPtr=46 BitCast=47 AddrSpaceCast=48
%term CleanupPad=49 CatchPad=50
%term ICmp=51 FCmp=52 PHI=53 Call=54 Select=55 UserOp1=56 UserOp2=57 VAArg=58 ExtractElement=59 InsertElement=60 ShuffleVector=61 ExtractValue=62 InsertValue=63 LandingPad=64
%term REG IMM MEM

%declare<void> stmt     <FUNCTION_STATE fstate>;
%declare<void> reg      <FUNCTION_STATE fstate>;
%declare<void> imm      <FUNCTION_STATE fstate>;
%declare<void> mem      <FUNCTION_STATE fstate>;
%%

reg:    stmt                { $cost[0].cost = $cost[1].cost;                    } = { $action[1](fstate); };
reg:    REG                 { $cost[0].cost = 1;                                } = { };
reg:    IMM                 { $cost[0].cost = 1;                                } = { };
imm:    Load(IMM)           { $cost[0].cost = 0;                                } = { };
imm:    IMM                 { $cost[0].cost = 0;                                } = { };
mem:    MEM                 { $cost[0].cost = 10;                               } = { };

stmt:   Ret(reg)            { $cost[0].cost = $cost[2].cost + 1;                } = { 
            /*
             * IR Ret takes a register argument
             * X86 Ret takes no argument, return value is passed by %eax
             */
            std::cerr << "\tleave" << std::endl
                      << "\tret"   << std::endl; 
        };
stmt:   Alloca(IMM)         { $cost[0].cost = 1;                                } = { 
            /*
             * IR Alloca takes one arguments for allocation size
             * X86 does not have correspondence for Alloca, but only uses $esp - size
             */
            // std::cerr << "subl $esp, $4" << "\t; perhaps we can change this!" << std::endl; 
            std::cerr << "\t; Allocate Space!" << std::endl; 
        }; 
stmt:   Load(reg)           { $cost[0].cost = $cost[2].cost + 1;    } = { 
            /*
             * IR Load takes one arguments for allocation size
             * X86 uses mov instruction, which takes two arguments
             */
            // prepare both operands first
            $action[2](fstate); 
            std::cerr << "\tmovl " << MRI2String(REG, $0) << ", " << MRI2String(REG, $2) << std::endl; 
        }; 
stmt:   Load(imm)           { $cost[0].cost = $cost[2].cost + 1;    } = { 
            $action[2](fstate); 
            std::cerr << "\tmovl " << MRI2String(REG, $0) << ", " << MRI2String(IMM, $2) << std::endl; 
        }; 
stmt:   Load(mem)           { $cost[0].cost = $cost[2].cost + 1;    } = { 
            $action[2](fstate); 
            std::cerr << "\tmovl " << MRI2String(REG, $0) << ", " << MRI2String(MEM, $2) << std::endl; 
        }; 
stmt:   Store(reg, reg)      { $cost[0].cost = $cost[2].cost + $cost[3].cost;    } = { 
            /*
             * IR Store takes one arguments for allocation size
             * X86 uses mov instruction, which takes two arguments
             */
            // prepare both operands first
            $action[2](fstate);
            $action[3](fstate);
            std::cerr << "\tmovl " << MRI2String(REG, $3) << ", " << MRI2String(REG, $2) << std::endl;
        }; 
stmt:   Store(imm, reg)      { $cost[0].cost = $cost[2].cost + $cost[3].cost;    } = { 
            $action[2](fstate);
            $action[3](fstate);
            std::cerr << "\tmovl " << MRI2String(REG, $3) << ", " << MRI2String(IMM, $2) << std::endl;
        }; 
stmt:   Store(mem, reg)      { $cost[0].cost = $cost[2].cost + $cost[3].cost;    } = { 
            $action[2](fstate);
            $action[3](fstate);
            std::cerr << "\tmovl " << MRI2String(REG, $3) << ", " << MRI2String(MEM, $2) << std::endl;
        }; 
stmt:   Add(reg, reg)       { $cost[0].cost = $cost[2].cost + $cost[3].cost + 2;    } = {
            /*
             * IR Add takes two arguments
             * X86 Add takes two argument, both operands cannot be from memory in the instruction
             */
            // prepare both operands first
            $action[2](fstate); 
            $action[3](fstate);
            // std::cerr << "ADD: "<< $3->val.val.i32s << std::endl;
            std::cerr << "\taddl " << MRI2String(REG, $3) << ", " << MRI2String(REG, $2)  << std::endl; 
        };
stmt:   Sub(reg, reg)       { $cost[0].cost = $cost[2].cost + $cost[3].cost + 2;    } = {
            /*
             * IR Sub takes two arguments
             * X86 Sub takes two argument, both operands cannot be from memory in the instruction
             */
            // prepare both operands first
            $action[2](fstate); 
            $action[3](fstate);
            // std::cerr << "SUB: "<< $3->val.val.i32s << std::endl;
            std::cerr << "\tsubl " << MRI2String(REG, $3) << ", " << MRI2String(REG, $2)  << std::endl; 
        };
stmt:   Mul(reg, reg)       { $cost[0].cost = $cost[2].cost + $cost[3].cost + 4;    } = {
            /*
             * IR Mul takes two arguments
             * X86 Mul takes two argument, both operands cannot be from memory in the instruction
             */
            // prepare both operands first
            $action[2](fstate); 
            $action[3](fstate);
            // std::cerr << "MUL: "<< $3->val.val.i32s << std::endl;
            std::cerr << "\timull " << MRI2String(REG, $3) << ", " << MRI2String(REG, $2)  << std::endl; 
        };
%%
