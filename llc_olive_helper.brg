%term DUMMY=0
%term Ret=1 Br=2 Switch=3 IndirectBr=4 Invoke=5 Resume=6 Unreachable=7 CleanupRet=8 CatchRet=9 CatchSwitch=10
%term Add=11 FAdd=12 Sub=13 FSub=14 Mul=15 FMul=16 UDiv=17 SDiv=18 FDiv=19 URem=20 SRem=21 FRem=22
%term Shl=23 LShr=24 AShr=25 And=26 Or=27 Xor=28
%term Alloca=29 Load=30 Store=31 GetElementPtr=32 Fence=33 AtomicCmpXchg=34 AtomicRMW=35
%term Trunc=36 ZExt=37 SExt=38 FPToUI=39 FPToSI=40 UIToFP=41 SIToFP=42 FPTrunc=43 FPExt=44 PtrToInt=45 IntToPtr=46 BitCast=47 AddrSpaceCast=48
%term CleanupPad=49 CatchPad=50
%term ICmp=51 FCmp=52 PHI=53 Call=54 Select=55 UserOp1=56 UserOp2=57 VAArg=58 ExtractElement=59 InsertElement=60 ShuffleVector=61 ExtractValue=62 InsertValue=63 LandingPad=64
%term REG IMM MEM

%declare<void> stmt     <FUNCTION_STATE fstate>;
%declare<void> vstmt    <FUNCTION_STATE fstate>;
%declare<void> reg      <FUNCTION_STATE fstate>;
%declare<void> imm      <FUNCTION_STATE fstate>;
%declare<void> mem      <FUNCTION_STATE fstate>;
%%

stmt:   vstmt               { return 1;                                         } = { $action[1](fstate); };

reg:    vstmt               { $cost[0].cost = $cost[1].cost;                    } = { $action[1](fstate); };
reg:    REG                 { $cost[0].cost = 1;                                } = { };
reg:    IMM                 { $cost[0].cost = 1;                                } = { };
imm:    Load(IMM)           { $cost[0].cost = 0;                                } = { };
imm:    IMM                 { $cost[0].cost = 0;                                } = { };
mem:    MEM                 { $cost[0].cost = 10;                               } = { };

vstmt:  Ret(reg)            { $cost[0].cost = $cost[2].cost + 1;                } = { 
            /*
             * IR Ret takes a register argument
             * X86 Ret takes no argument, return value is passed by %eax
             */
            fstate->RestoreStack();
            fstate->AddInst(new X86Inst("leave"));
            fstate->AddInst(new X86Inst("ret"));
        };
vstmt:  Alloca(IMM)         { $cost[0].cost = 1;                                } = { 
            /*
             * IR Alloca takes one arguments for allocation size
             * X86 does not have correspondence for Alloca, but only uses $esp - size
             */
            fstate->CreateLocal($0, 8);
        }; 
vstmt:  Load(reg)           { $cost[0].cost = $cost[2].cost + 1;    } = { 
            /*
             * IR Load takes one arguments for allocation size
             * X86 uses mov instruction, which takes two arguments
             */
            // prepare both operands first
            $action[2](fstate); 
            fstate->AddInst(new X86Inst("movq", 
                        new X86Operand(fstate, OP_TYPE::X86Reg, $0->val),
                        new X86Operand(fstate, OP_TYPE::X86Reg, $2->val)
                    ));
        }; 
vstmt:  Load(imm)           { $cost[0].cost = $cost[2].cost + 1;    } = { 
            $action[2](fstate); 
            fstate->AddInst(new X86Inst("movq", 
                        new X86Operand(fstate, OP_TYPE::X86Reg, $0->val),
                        new X86Operand(fstate, OP_TYPE::X86Imm, $2->val)
                    ));
        }; 
vstmt:  Load(mem)           { $cost[0].cost = $cost[2].cost + 1;    } = { 
            $action[2](fstate); 
            fstate->AddInst(new X86Inst("movq", 
                        new X86Operand(fstate, OP_TYPE::X86Reg, $0->val),
                        fstate->GetLocalMemoryAddress($2)
                    ));
        }; 
vstmt:  Store(reg, reg)      { $cost[0].cost = $cost[2].cost + $cost[3].cost;    } = { 
            /*
             * IR Store takes one arguments for allocation size
             * X86 uses mov instruction, which takes two arguments
             */
            // prepare both operands first
            $action[2](fstate);
            $action[3](fstate);
            fstate->AddInst(new X86Inst("movq", 
                        new X86Operand(fstate, OP_TYPE::X86Reg, $3->val),
                        new X86Operand(fstate, OP_TYPE::X86Reg, $2->val)
                    ));
        }; 
vstmt:  Store(imm, reg)      { $cost[0].cost = $cost[2].cost + $cost[3].cost;    } = { 
            $action[2](fstate);
            $action[3](fstate);
            fstate->AddInst(new X86Inst("movq", 
                        new X86Operand(fstate, OP_TYPE::X86Reg, $3->val),
                        new X86Operand(fstate, OP_TYPE::X86Imm, $2->val)
                    ));
        }; 
vstmt:  Store(mem, reg)      { $cost[0].cost = $cost[2].cost + $cost[3].cost;    } = { 
            $action[2](fstate);
            $action[3](fstate);
            fstate->AddInst(new X86Inst("movq", 
                        new X86Operand(fstate, OP_TYPE::X86Reg, $3->val),
                        fstate->GetLocalMemoryAddress($2)
                    ));
        }; 
vstmt:  Add(reg, reg)       { $cost[0].cost = $cost[2].cost + $cost[3].cost + 2;    } = {
            /*
             * IR Add takes two arguments
             * X86 Add takes two argument, both operands cannot be from memory in the instruction
             */
            // prepare both operands first
            $action[2](fstate); 
            $action[3](fstate);
            fstate->AddInst(new X86Inst("addq", 
                        new X86Operand(fstate, OP_TYPE::X86Reg, $3->val),
                        new X86Operand(fstate, OP_TYPE::X86Reg, $2->val)
                    ));
        };
vstmt:  Sub(reg, reg)       { $cost[0].cost = $cost[2].cost + $cost[3].cost + 2;    } = {
            /*
             * IR Sub takes two arguments
             * X86 Sub takes two argument, both operands cannot be from memory in the instruction
             */
            // prepare both operands first
            $action[2](fstate); 
            $action[3](fstate);
            fstate->AddInst(new X86Inst("subq", 
                        new X86Operand(fstate, OP_TYPE::X86Reg, $3->val),
                        new X86Operand(fstate, OP_TYPE::X86Reg, $2->val)
                    ));
        };
vstmt:  Mul(reg, reg)       { $cost[0].cost = $cost[2].cost + $cost[3].cost + 4;    } = {
            /*
             * IR Mul takes two arguments
             * X86 Mul takes two argument, both operands cannot be from memory in the instruction
             */
            // prepare both operands first
            $action[2](fstate); 
            $action[3](fstate);
            fstate->AddInst(new X86Inst("imulq", 
                        new X86Operand(fstate, OP_TYPE::X86Reg, $3->val),
                        new X86Operand(fstate, OP_TYPE::X86Reg, $2->val)
                    ));
        };
%%
