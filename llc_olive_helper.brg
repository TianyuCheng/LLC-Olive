%term Ret=1 Br=2 Switch=3 IndirectBr=4 Invoke=5 Resume=6 Unreachable=7 CleanupRet=8 CatchRet=9 CatchSwitch=10
%term Add=11 FAdd=12 Sub=13 FSub=14 Mul=15 FMul=16 UDiv=17 SDiv=18 FDiv=19 URem=20 SRem=21 FRem=22
%term Shl=23 LShr=24 AShr=25 And=26 Or=27 Xor=28
%term Alloca=29 Load=30 Store=31 GetElementPtr=32 Fence=33 AtomicCmpXchg=34 AtomicRMW=35
%term Trunc=36 ZExt=37 SExt=38 FPToUI=39 FPToSI=40 UIToFP=41 SIToFP=42 FPTrunc=43 FPExt=44 PtrToInt=45 IntToPtr=46 BitCast=47 AddrSpaceCast=48
%term CleanupPad=49 CatchPad=50
%term ICmp=51 FCmp=52 PHI=53 Call=54 Select=55 UserOp1=56 UserOp2=57 VAArg=58 ExtractElement=59 InsertElement=60 ShuffleVector=61 ExtractValue=62 InsertValue=63 LandingPad=64
%term REG IMM MEM

%declare<void> stmt<int indent>;
%declare<void> rim<int indent>;
%declare<void> ri<int indent>;
%declare<void> reg<int indent>;
%declare<void> imm<int indent>;
%declare<void> mem<int indent>;
    
%declare<void> ret<int indent>;
%declare<void> br<int indent>;
%declare<void> switch<int indent>;
%declare<void> indirectbr<int indent>;
%declare<void> invoke<int indent>;
%declare<void> resume<int indent>;
%declare<void> unreachable<int indent>;
%declare<void> cleanupret<int indent>;
%declare<void> catchret<int indent>;
%declare<void> catchswitch<int indent>;
%declare<void> add<int indent>;
%declare<void> fadd<int indent>;
%declare<void> sub<int indent>;
%declare<void> fsub<int indent>;
%declare<void> mul<int indent>;
%declare<void> fmul<int indent>;
%declare<void> udiv<int indent>;
%declare<void> sdiv<int indent>;
%declare<void> fdiv<int indent>;
%declare<void> urem<int indent>;
%declare<void> srem<int indent>;
%declare<void> frem<int indent>;
%declare<void> alloca<int indent>;
%declare<void> load<int indent>;
%declare<void> store<int indent>;
%declare<void> getelementptr<int indent>;
%declare<void> fence<int indent>;
%declare<void> atomiccmpxchg<int indent>;
%declare<void> atomicrmw<int indent>;
%%

ri:    stmt   { $cost[0].cost = $cost[1].cost; } = { /* TODO: match reg here */ };
rim:   stmt   { $cost[0].cost = $cost[1].cost; } = { /* TODO: match reg here */ };
rim:   reg    { $cost[0].cost = $cost[1].cost; } = { /* TODO: match reg here */ };
rim:   imm    { $cost[0].cost = $cost[1].cost; } = { /* TODO: match imm here */ };
rim:   mem    { $cost[0].cost = $cost[1].cost; } = { /* TODO: match mem here */ };
ri:    reg    { $cost[0].cost = $cost[1].cost; } = { /* TODO: match reg here */ };
ri:    imm    { $cost[0].cost = $cost[1].cost; } = { /* TODO: match imm here */ };
reg:   REG    { $cost[0].cost = 1;             } = { /* TODO: match reg here */ };
imm:   IMM    { $cost[0].cost = 0;             } = { /* TODO: match imm here */ };
mem:   MEM    { $cost[0].cost = 10;            } = { /* TODO: match mem here */ };
    
stmt:	ret { $cost[0].cost = $cost[1].cost; } = { };
ret:	Ret(ri) { $cost[0].cost = $cost[2].cost + 1; } = { };

stmt:	br { $cost[0].cost = $cost[1].cost; } = { };
br:	Br(ri) { $cost[0].cost = $cost[2].cost + 1; } = { };

stmt:	switch { $cost[0].cost = $cost[1].cost; } = { };
switch:	Switch(ri) { $cost[0].cost = $cost[2].cost + 1; } = { };

stmt:	indirectbr { $cost[0].cost = $cost[1].cost; } = { };
indirectbr:	IndirectBr(ri) { $cost[0].cost = $cost[2].cost + 1; } = { };

stmt:	invoke { $cost[0].cost = $cost[1].cost; } = { };
invoke:	Invoke(ri) { $cost[0].cost = $cost[2].cost + 1; } = { };

stmt:	resume { $cost[0].cost = $cost[1].cost; } = { };
resume:	Resume(ri) { $cost[0].cost = $cost[2].cost + 1; } = { };

stmt:	unreachable { $cost[0].cost = $cost[1].cost; } = { };
unreachable:	Unreachable(ri) { $cost[0].cost = $cost[2].cost + 1; } = { };

stmt:	cleanupret { $cost[0].cost = $cost[1].cost; } = { };
cleanupret:	CleanupRet(ri) { $cost[0].cost = $cost[2].cost + 1; } = { };

stmt:	catchret { $cost[0].cost = $cost[1].cost; } = { };
catchret:	CatchRet(ri) { $cost[0].cost = $cost[2].cost + 1; } = { };

stmt:	catchswitch { $cost[0].cost = $cost[1].cost; } = { };
catchswitch:	CatchSwitch(ri) { $cost[0].cost = $cost[2].cost + 1; } = { };

stmt:	add { $cost[0].cost = $cost[1].cost; } = { };
add:	Add(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; } = { };

stmt:	fadd { $cost[0].cost = $cost[1].cost; } = { };
fadd:	FAdd(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 5; } = { };

stmt:	sub { $cost[0].cost = $cost[1].cost; } = { };
sub:	Sub(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; } = { };

stmt:	fsub { $cost[0].cost = $cost[1].cost; } = { };
fsub:	FSub(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 5; } = { };

stmt:	mul { $cost[0].cost = $cost[1].cost; } = { };
mul:	Mul(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 2; } = { };

stmt:	fmul { $cost[0].cost = $cost[1].cost; } = { };
fmul:	FMul(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 10; } = { };

stmt:	udiv { $cost[0].cost = $cost[1].cost; } = { };
udiv:	UDiv(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 4; } = { };

stmt:	sdiv { $cost[0].cost = $cost[1].cost; } = { };
sdiv:	SDiv(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 4; } = { };

stmt:	fdiv { $cost[0].cost = $cost[1].cost; } = { };
fdiv:	FDiv(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 20; } = { };

stmt:	urem { $cost[0].cost = $cost[1].cost; } = { };
urem:	URem(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 6; } = { };

stmt:	srem { $cost[0].cost = $cost[1].cost; } = { };
srem:	SRem(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 6; } = { };

stmt:	frem { $cost[0].cost = $cost[1].cost; } = { };
frem:	FRem(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 30; } = { };

stmt:	alloca { $cost[0].cost = $cost[1].cost; } = { };
alloca:	Alloca(ri) { $cost[0].cost = $cost[2].cost + 1; } = { };

stmt:	load { $cost[0].cost = $cost[1].cost; } = { };
load:	Load(ri) { $cost[0].cost = $cost[2].cost + 1; } = { };

stmt:	store { $cost[0].cost = $cost[1].cost; } = { };
store:	Store(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; } = { };

stmt:	getelementptr { $cost[0].cost = $cost[1].cost; } = { };
getelementptr:	GetElementPtr(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; } = { };

stmt:	fence { $cost[0].cost = $cost[1].cost; } = { };
fence:	Fence(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; } = { };

stmt:	atomiccmpxchg { $cost[0].cost = $cost[1].cost; } = { };
atomiccmpxchg:	AtomicCmpXchg(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; } = { };

stmt:	atomicrmw { $cost[0].cost = $cost[1].cost; } = { };
atomicrmw:	AtomicRMW(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; } = { };

%%
