%term DUMMY=0
%term Ret=1 Br=2 Switch=3 IndirectBr=4 Invoke=5 Resume=6 Unreachable=7 CleanupRet=8 CatchRet=9 CatchSwitch=10
%term Add=11 FAdd=12 Sub=13 FSub=14 Mul=15 FMul=16 UDiv=17 SDiv=18 FDiv=19 URem=20 SRem=21 FRem=22
%term Shl=23 LShr=24 AShr=25 And=26 Or=27 Xor=28
%term Alloca=29 Load=30 Store=31 GetElementPtr=32 Fence=33 AtomicCmpXchg=34 AtomicRMW=35
%term Trunc=36 ZExt=37 SExt=38 FPToUI=39 FPToSI=40 UIToFP=41 SIToFP=42 FPTrunc=43 FPExt=44 PtrToInt=45 IntToPtr=46 BitCast=47 AddrSpaceCast=48
%term CleanupPad=49 CatchPad=50
%term ICmp=51 FCmp=52 PHI=53 Call=54 Select=55 UserOp1=56 UserOp2=57 VAArg=58 ExtractElement=59 InsertElement=60 ShuffleVector=61 ExtractValue=62 InsertValue=63 LandingPad=64
%term REG IMM MEM

%declare<void> stmt     <FUNCTION_STATE fstate>;
%declare<void>  ri      <FUNCTION_STATE fstate>;
%declare<void>  mr      <FUNCTION_STATE fstate>;
%declare<void> mri      <FUNCTION_STATE fstate>;
%declare<void> reg      <FUNCTION_STATE fstate>;
%declare<void> imm      <FUNCTION_STATE fstate>;
%declare<void> mem      <FUNCTION_STATE fstate>;
%%

mri:    mem                 { $cost[0].cost = $cost[1].cost;                    } = { $action[1](fstate); };
mri:    reg                 { $cost[0].cost = $cost[1].cost;                    } = { $action[1](fstate); };
mri:    imm                 { $cost[0].cost = $cost[1].cost;                    } = { $action[1](fstate); };

ri:     reg                 { $cost[0].cost = $cost[1].cost;                    } = { $action[1](fstate); };
ri:     imm                 { $cost[0].cost = $cost[1].cost;                    } = { $action[1](fstate); };

mr:     mem                 { $cost[0].cost = $cost[1].cost;                    } = { $action[1](fstate); };
mr:     reg                 { $cost[0].cost = $cost[1].cost;                    } = { $action[1](fstate); };

reg:    stmt                { $cost[0].cost = $cost[1].cost;                    } = { $action[1](fstate); };
reg:    REG                 { $cost[0].cost = 1;                                } = { };
reg:    IMM                 { $cost[0].cost = 1;                                } = { };
imm:    Load(IMM)           { $cost[0].cost = 0;                                } = { };
imm:    IMM                 { $cost[0].cost = 0;                                } = { };
mem:    MEM                 { $cost[0].cost = 10;                               } = { };

stmt:   Ret(reg)            { $cost[0].cost = $cost[2].cost + 1;                } = { 
            /*
             * IR Ret takes a register argument
             * X86 Ret takes no argument, return value is passed by %eax
             */
            std::cerr << "leave" << std::endl
                      << "ret"   << std::endl; 
        };
stmt:   Alloca(IMM)         { $cost[0].cost = 1;                                } = { 
            /*
             * IR Alloca takes one arguments for allocation size
             * X86 does not have correspondence for Alloca, but only uses $esp - size
             */
            std::cerr << "subl $esp, $4" << std::endl; 
        }; 
stmt:   Load(mri)           { $cost[0].cost = $cost[2].cost + 1;    } = { 
            /*
             * IR Load takes one arguments for allocation size
             * X86 uses mov instruction, which takes two arguments
             */
            // prepare both operands first
            $action[2](fstate); 
            std::cerr << "movl " << MRI2String(REG, $2) << ", " << "<SOME MRI VALUE NOT IMPLEMENTED>" << std::endl; 
        }; 
stmt:   Store(ri, mr)      { $cost[0].cost = $cost[2].cost + $cost[3].cost;    } = { 
            /*
             * IR Store takes one arguments for allocation size
             * X86 uses mov instruction, which takes two arguments
             */
            // prepare both operands first
            $action[2](fstate);
            $action[3](fstate);
            std::cerr << "movl " << "<SOME MRI VALUE NOT IMPLEMENTED>" << ", " << MRI2String(REG, $2) << std::endl;
        }; 
stmt:   Add(mri, reg)       { $cost[0].cost = $cost[2].cost + $cost[3].cost;    } = {
            /*
             * IR Add takes two arguments
             * X86 Add takes two argument, both operands cannot be from memory in the instruction
             */
            // prepare both operands first
            $action[2](fstate); 
            $action[3](fstate);
            std::cerr << "addl " << MRI2String(REG, $3) << ", " << "<SOME MRI VALUE NOT IMPLEMENTED>" << std::endl; 
        };
%%
