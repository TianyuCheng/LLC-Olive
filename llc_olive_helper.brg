%term Ret=1 Br=2 Switch=3 IndirectBr=4 Invoke=5 Resume=6 Unreachable=7 CleanupRet=8 CatchRet=9 CatchSwitch=10
%term Add=11 FAdd=12 Sub=13 FSub=14 Mul=15 FMul=16 UDiv=17 SDiv=18 FDiv=19 URem=20 SRem=21 FRem=22
%term Shl=23 LShr=24 AShr=25 And=26 Or=27 Xor=28
%term Alloca=29 Load=30 Store=31 GetElementPtr=32 Fence=33 AtomicCmpXchg=34 AtomicRMW=35
%term Trunc=36 ZExt=37 SExt=38 FPToUI=39 FPToSI=40 UIToFP=41 SIToFP=42 FPTrunc=43 FPExt=44 PtrToInt=45 IntToPtr=46 BitCast=47 AddrSpaceCast=48
%term CleanupPad=49 CatchPad=50
%term ICmp=51 FCmp=52 PHI=53 Call=54 Select=55 UserOp1=56 UserOp2=57 VAArg=58 ExtractElement=59 InsertElement=60 ShuffleVector=61 ExtractValue=62 InsertValue=63 LandingPad=64
%term REG IMM MEM

%declare<void> stmt<FUNCTION_STATE FuncState>;
%declare<void> rim<FUNCTION_STATE  FuncState>;
%declare<void> ri<FUNCTION_STATE   FuncState>;
%declare<void> reg<FUNCTION_STATE  FuncState>;
%declare<void> imm<FUNCTION_STATE  FuncState>;
%declare<void> mem<FUNCTION_STATE  FuncState>;
    
%declare<void> ret<FUNCTION_STATE FuncState>;
%declare<void> br<FUNCTION_STATE FuncState>;
%declare<void> switch<FUNCTION_STATE FuncState>;
%declare<void> indirectbr<FUNCTION_STATE FuncState>;
%declare<void> invoke<FUNCTION_STATE FuncState>;
%declare<void> resume<FUNCTION_STATE FuncState>;
%declare<void> unreachable<FUNCTION_STATE FuncState>;
%declare<void> cleanupret<FUNCTION_STATE FuncState>;
%declare<void> catchret<FUNCTION_STATE FuncState>;
%declare<void> catchswitch<FUNCTION_STATE FuncState>;
%declare<void> add<FUNCTION_STATE FuncState>;
%declare<void> fadd<FUNCTION_STATE FuncState>;
%declare<void> sub<FUNCTION_STATE FuncState>;
%declare<void> fsub<FUNCTION_STATE FuncState>;
%declare<void> mul<FUNCTION_STATE FuncState>;
%declare<void> fmul<FUNCTION_STATE FuncState>;
%declare<void> udiv<FUNCTION_STATE FuncState>;
%declare<void> sdiv<FUNCTION_STATE FuncState>;
%declare<void> fdiv<FUNCTION_STATE FuncState>;
%declare<void> urem<FUNCTION_STATE FuncState>;
%declare<void> srem<FUNCTION_STATE FuncState>;
%declare<void> frem<FUNCTION_STATE FuncState>;
%declare<void> shl<FUNCTION_STATE FuncState>;
%declare<void> lshr<FUNCTION_STATE FuncState>;
%declare<void> ashr<FUNCTION_STATE FuncState>;
%declare<void> and<FUNCTION_STATE FuncState>;
%declare<void> or<FUNCTION_STATE FuncState>;
%declare<void> xor<FUNCTION_STATE FuncState>;
%declare<void> alloca<FUNCTION_STATE FuncState>;
%declare<void> load<FUNCTION_STATE FuncState>;
%declare<void> store<FUNCTION_STATE FuncState>;
%declare<void> getelementptr<FUNCTION_STATE FuncState>;
%declare<void> fence<FUNCTION_STATE FuncState>;
%declare<void> atomiccmpxchg<FUNCTION_STATE FuncState>;
%declare<void> atomicrmw<FUNCTION_STATE FuncState>;
%%

ri:    stmt   { $cost[0].cost = $cost[1].cost; } = { /* TODO: match reg here */ };
rim:   stmt   { $cost[0].cost = $cost[1].cost; } = { /* TODO: match reg here */ };
rim:   reg    { $cost[0].cost = $cost[1].cost; } = { /* TODO: match reg here */ };
rim:   imm    { $cost[0].cost = $cost[1].cost; } = { /* TODO: match imm here */ };
rim:   mem    { $cost[0].cost = $cost[1].cost; } = { /* TODO: match mem here */ };
ri:    reg    { $cost[0].cost = $cost[1].cost; } = { /* TODO: match reg here */ };
ri:    imm    { $cost[0].cost = $cost[1].cost; } = { /* TODO: match imm here */ };
reg:   REG    { $cost[0].cost = 1;             } = { /* TODO: match reg here */ };
imm:   IMM    { $cost[0].cost = 0;             } = { /* TODO: match imm here */ };
mem:   MEM    { $cost[0].cost = 10;            } = { /* TODO: match mem here */ };
    
stmt:	ret { $cost[0].cost = $cost[1].cost; } = { };
ret:	Ret(ri) { $cost[0].cost = $cost[2].cost + 1; } = { };

stmt:	br { $cost[0].cost = $cost[1].cost; } = { };
br:	Br(ri) { $cost[0].cost = $cost[2].cost + 1; } = { };

stmt:	switch { $cost[0].cost = $cost[1].cost; } = { };
switch:	Switch(ri) { $cost[0].cost = $cost[2].cost + 1; } = { };

stmt:	indirectbr { $cost[0].cost = $cost[1].cost; } = { };
indirectbr:	IndirectBr(ri) { $cost[0].cost = $cost[2].cost + 1; } = { };

stmt:	invoke { $cost[0].cost = $cost[1].cost; } = { };
invoke:	Invoke(ri) { $cost[0].cost = $cost[2].cost + 1; } = { };

stmt:	resume { $cost[0].cost = $cost[1].cost; } = { };
resume:	Resume(ri) { $cost[0].cost = $cost[2].cost + 1; } = { };

stmt:	unreachable { $cost[0].cost = $cost[1].cost; } = { };
unreachable:	Unreachable(ri) { $cost[0].cost = $cost[2].cost + 1; } = { };

stmt:	cleanupret { $cost[0].cost = $cost[1].cost; } = { };
cleanupret:	CleanupRet(ri) { $cost[0].cost = $cost[2].cost + 1; } = { };

stmt:	catchret { $cost[0].cost = $cost[1].cost; } = { };
catchret:	CatchRet(ri) { $cost[0].cost = $cost[2].cost + 1; } = { };

stmt:	catchswitch { $cost[0].cost = $cost[1].cost; } = { };
catchswitch:	CatchSwitch(ri) { $cost[0].cost = $cost[2].cost + 1; } = { };

stmt:	add { $cost[0].cost = $cost[1].cost; } = { };
add:	Add(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; } = {
            if (OP_LABEL($2) == IMM)
                std::cerr << "OPERAND IS IMM: " << $2->val.val.i32s << std::endl;
            if (OP_LABEL($3) == IMM)
                std::cerr << "OPERAND IS IMM: " << $3->val.val.i32s << std::endl;
        };

stmt:	fadd { $cost[0].cost = $cost[1].cost; } = { };
fadd:	FAdd(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 5; } = {
            if (OP_LABEL($2) == IMM)
                std::cerr << "OPERAND IS IMM: " << $2->val.val.i32s << std::endl;
            if (OP_LABEL($3) == IMM)
                std::cerr << "OPERAND IS IMM: " << $3->val.val.i32s << std::endl;
        };

stmt:	sub { $cost[0].cost = $cost[1].cost; } = { };
sub:	Sub(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; } = {
            if (OP_LABEL($2) == IMM)
                std::cerr << "OPERAND IS IMM: " << $2->val.val.i32s << std::endl;
            if (OP_LABEL($3) == IMM)
                std::cerr << "OPERAND IS IMM: " << $3->val.val.i32s << std::endl;
        };

stmt:	fsub { $cost[0].cost = $cost[1].cost; } = { };
fsub:	FSub(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 5; } = {
            if (OP_LABEL($2) == IMM)
                std::cerr << "OPERAND IS IMM: " << $2->val.val.i32s << std::endl;
            if (OP_LABEL($3) == IMM)
                std::cerr << "OPERAND IS IMM: " << $3->val.val.i32s << std::endl;
        };

stmt:	mul { $cost[0].cost = $cost[1].cost; } = { };
mul:	Mul(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 2; } = {
            if (OP_LABEL($2) == IMM)
                std::cerr << "OPERAND IS IMM: " << $2->val.val.i32s << std::endl;
            if (OP_LABEL($3) == IMM)
                std::cerr << "OPERAND IS IMM: " << $3->val.val.i32s << std::endl;
        };

stmt:	fmul { $cost[0].cost = $cost[1].cost; } = { };
fmul:	FMul(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 10; } = {
            if (OP_LABEL($2) == IMM)
                std::cerr << "OPERAND IS IMM: " << $2->val.val.i32s << std::endl;
            if (OP_LABEL($3) == IMM)
                std::cerr << "OPERAND IS IMM: " << $3->val.val.i32s << std::endl;
        };

stmt:	udiv { $cost[0].cost = $cost[1].cost; } = { };
udiv:	UDiv(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 4; } = {
            if (OP_LABEL($2) == IMM)
                std::cerr << "OPERAND IS IMM: " << $2->val.val.i32s << std::endl;
            if (OP_LABEL($3) == IMM)
                std::cerr << "OPERAND IS IMM: " << $3->val.val.i32s << std::endl;
        };

stmt:	sdiv { $cost[0].cost = $cost[1].cost; } = { };
sdiv:	SDiv(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 4; } = {
            if (OP_LABEL($2) == IMM)
                std::cerr << "OPERAND IS IMM: " << $2->val.val.i32s << std::endl;
            if (OP_LABEL($3) == IMM)
                std::cerr << "OPERAND IS IMM: " << $3->val.val.i32s << std::endl;
        };

stmt:	fdiv { $cost[0].cost = $cost[1].cost; } = { };
fdiv:	FDiv(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 20; } = {
            if (OP_LABEL($2) == IMM)
                std::cerr << "OPERAND IS IMM: " << $2->val.val.i32s << std::endl;
            if (OP_LABEL($3) == IMM)
                std::cerr << "OPERAND IS IMM: " << $3->val.val.i32s << std::endl;
        };

stmt:	urem { $cost[0].cost = $cost[1].cost; } = { };
urem:	URem(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 6; } = {
            if (OP_LABEL($2) == IMM)
                std::cerr << "OPERAND IS IMM: " << $2->val.val.i32s << std::endl;
            if (OP_LABEL($3) == IMM)
                std::cerr << "OPERAND IS IMM: " << $3->val.val.i32s << std::endl;
        };

stmt:	srem { $cost[0].cost = $cost[1].cost; } = { };
srem:	SRem(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 6; } = {
            if (OP_LABEL($2) == IMM)
                std::cerr << "OPERAND IS IMM: " << $2->val.val.i32s << std::endl;
            if (OP_LABEL($3) == IMM)
                std::cerr << "OPERAND IS IMM: " << $3->val.val.i32s << std::endl;
        };

stmt:	frem { $cost[0].cost = $cost[1].cost; } = { };
frem:	FRem(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 30; } = {
            if (OP_LABEL($2) == IMM)
                std::cerr << "OPERAND IS IMM: " << $2->val.val.i32s << std::endl;
            if (OP_LABEL($3) == IMM)
                std::cerr << "OPERAND IS IMM: " << $3->val.val.i32s << std::endl;
        };

stmt:	alloca { $cost[0].cost = $cost[1].cost; } = { 
            std::cerr << "Hello, Stmt -> Alloca" << std::endl; 
            $action[1](0);
            };
alloca:	Alloca(ri) { $cost[0].cost = $cost[2].cost + 1; } = {
                std::cerr << "Hello Alloca" << std::endl;
                $action[2](0);
            };

stmt:	load { $cost[0].cost = $cost[1].cost; } = { 
            std::cerr << "Hello, Stmt -> Load" << std::endl; 
            $action[1](0);
            };
load:	Load(ri) { $cost[0].cost = $cost[2].cost + 1; } = { 
                std::cerr << "Hello Load" << std::endl;
                $action[2](0);
            };

stmt:	store { $cost[0].cost = $cost[1].cost; } = { 
            std::cerr << "Hello, Stmt -> Store" << std::endl; 
            $action[1](0);
            };
store:	Store(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; } = {
                std::cerr << "Hello Store" << std::endl;
                $action[2](0);
                $action[3](0);
            };

stmt:	getelementptr { $cost[0].cost = $cost[1].cost; } = { 
            std::cerr << "Hello, Stmt -> GetElementPtr" << std::endl; 
            $action[1](0);
            };
getelementptr:	GetElementPtr(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; } = { };

stmt:	fence { $cost[0].cost = $cost[1].cost; } = { 
            std::cerr << "Hello, Stmt -> Fence" << std::endl; 
            $action[1](0);
            };
fence:	Fence(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; } = { };

stmt:	atomiccmpxchg { $cost[0].cost = $cost[1].cost; } = { 
            std::cerr << "Hello, Stmt -> AtomicCmpXchg" << std::endl; 
            $action[1](0);
            };
atomiccmpxchg:	AtomicCmpXchg(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; } = { };

stmt:	atomicrmw { $cost[0].cost = $cost[1].cost; } = { 
            std::cerr << "Hello, Stmt -> AtomicRMW" << std::endl; 
            $action[1](0);
            };
atomicrmw:	AtomicRMW(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; } = { };

stmt:	shl { $cost[0].cost = $cost[1].cost; } = { };
shl:	Shl(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; } = { };

stmt:	lshr { $cost[0].cost = $cost[1].cost; } = { };
lshr:	LShr(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; } = { };

stmt:	ashr { $cost[0].cost = $cost[1].cost; } = { };
ashr:	AShr(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; } = { };

stmt:	and { $cost[0].cost = $cost[1].cost; } = { };
and:	And(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; } = { };

stmt:	or { $cost[0].cost = $cost[1].cost; } = { };
or:	Or(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; } = { };

stmt:	xor { $cost[0].cost = $cost[1].cost; } = { };
xor:	Xor(rim, ri) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; } = { };

%%
