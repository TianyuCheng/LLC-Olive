%{
#include <iostream>
#include <fstream>
#include <cassert>
#include <vector>
#include <map>

#include <llvm/Support/CommandLine.h>
#include <llvm/IR/Module.h>
#include <llvm/IRReader/IRReader.h>
#include <llvm/IR/LLVMContext.h>
#include <llvm/Support/MemoryBuffer.h>
#include <llvm/Support/raw_ostream.h>
#include <llvm/Support/SourceMgr.h>

#define PARSE_DEBUG 0

typedef struct tree {
	int op;
	struct tree *kids[2];
	int val;
	struct { struct burm_state *state; } x;
} *NODEPTR, *Tree;
#define GET_KIDS(p)	((p)->kids)
#define PANIC printf
#define STATE_LABEL(p) ((p)->x.state)
#define SET_STATE(p,s) (p)->x.state=(s)
#define DEFAULT_COST	break
#define NO_ACTION(x)

typedef struct COST {
    int cost;
} COST;
#define COST_LESS(a,b) ((a).cost < (b).cost)

static COST COST_INFINITY = { 32767 };
static COST COST_ZERO     = { 0 };

/*static char* burm_string = "FOO";*/
static int _ern = 0;

static int shouldTrace = 0;
static int shouldCover = 0;

int OP_LABEL(NODEPTR p) {
	switch (p->op) {
	case CNSTI:  if (p->val == 0) return 661 /* I0I */;
	default:     return p->op;
	}
}

static void burm_trace(NODEPTR, int, COST);
%}

%term BURP=0 ADDI=309 ADDRLP=295
%declare<void> stmt<int indent>;
%%
stmt: BURP
    { return 1; }
    = {
        std::cout<< "Hello World!\n" << std::endl;
    };
%%


/* burm_trace - print trace message for matching p */
static void burm_trace(NODEPTR p, int eruleno, COST cost) {
}

using namespace llvm;

static cl::opt<std::string>
InputFilename(cl::Positional, cl::desc("<input bitcode>"), cl::init("-"));

static cl::opt<std::string>
OutputFilename("o", cl::desc("<output filename>"), cl::value_desc("filename"));

static cl::opt<int>
NumRegs("num_regs", cl::desc("<number of registers available>"), cl::init(32));

#if 0
/**
 * Generate an expression tree from
 * a bitcode file
 * */
void gen_expr_tree(std::string filename) {
    LLVMContext context;
    SMDiagnostic error;
    std::unique_ptr<Module> module = parseIRFile(StringRef(filename.c_str()), error, context);
    Module::FunctionListType &function_list = module->getFunctionList();

    for (Function &func : function_list) {
        Function::BasicBlockListType &basic_blocks = func.getBasicBlockList();
        std::map<Instruction*, Tree> tree_map;
        for (BasicBlock &bb : basic_blocks) {
            for (auto inst = bb.begin(); inst != bb.end(); inst++) {
                // Instruction &instruction = *inst;
                // Tree t = new tree;
                // t->op = instruction.getOpcode();
                // int num_operands = instruction.getNumOperands();
                // for (int i = 0; i < num_operands; i++) {
                //     Value *v = instruction.getOperand(i);
                //     Instruction *def = dyn_cast<Instruction>(v);
                // }
            } // end of instruction loop
        } // end of basic block loop
    } // end of function loop
}
#endif

int main(int argc, char *argv[])
{
    cl::ParseCommandLineOptions(argc, argv, "llc-olive\n");
#if PARSE_DEBUG
    std::cout << "Input: " << InputFilename << std::endl;
    std::cout << "Output:" << OutputFilename << std::endl;
    std::cout << "num regs:" << NumRegs << std::endl;
#endif
    return 0;
}
