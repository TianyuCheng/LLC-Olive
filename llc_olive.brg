%{
#include "llc_olive_helper.h"
%}

%term DUMMY=0
%term Ret=1 Br=2 Switch=3 IndirectBr=4 Invoke=5 Resume=6 Unreachable=7 CleanupRet=8 CatchRet=9 CatchSwitch=10
%term Add=11 FAdd=12 Sub=13 FSub=14 Mul=15 FMul=16 UDiv=17 SDiv=18 FDiv=19 URem=20 SRem=21 FRem=22
%term Shl=23 LShr=24 AShr=25 And=26 Or=27 Xor=28
%term Alloca=29 Load=30 Store=31 GetElementPtr=32 Fence=33 AtomicCmpXchg=34 AtomicRMW=35
%term Trunc=36 ZExt=37 SExt=38 FPToUI=39 FPToSI=40 UIToFP=41 SIToFP=42 FPTrunc=43 FPExt=44 PtrToInt=45 IntToPtr=46 BitCast=47 AddrSpaceCast=48
%term CleanupPad=49 CatchPad=50
%term ICmp=51 FCmp=52 PHI=53 Call=54 Select=55 UserOp1=56 UserOp2=57 VAArg=58 ExtractElement=59 InsertElement=60 ShuffleVector=61 ExtractValue=62 InsertValue=63 LandingPad=64
%term REG IMM MEM LABEL ARGS NOARGS

%declare<void> stmt     <FUNCTION_STATE fstate>;
%declare<void> value    <FUNCTION_STATE fstate>;
%declare<void> ri       <FUNCTION_STATE fstate>;
%declare<void> rm       <FUNCTION_STATE fstate>;
%declare<void> reg      <FUNCTION_STATE fstate>;
%declare<void> imm      <FUNCTION_STATE fstate>;
%declare<void> mem      <FUNCTION_STATE fstate>;
%declare<void> cond     <FUNCTION_STATE fstate>;
%declare<void> label    <FUNCTION_STATE fstate>;
%declare<void> args     <FUNCTION_STATE fstate, int n>;
%%

stmt:   reg                 { return 1;                                         } = { $action[1](fstate); };
stmt:   mem                 { return 1;                                         } = { $action[1](fstate); };

value:  reg                 { $cost[0].cost = $cost[1].cost;                    } = { $action[1](fstate); };
value:  imm                 { $cost[0].cost = $cost[1].cost;                    } = { $action[1](fstate); };
value:  mem                 { $cost[0].cost = $cost[1].cost;                    } = { $action[1](fstate); };

rm:     reg                 { $cost[0].cost = $cost[1].cost;                    } = { $action[1](fstate); };
rm:     mem                 { $cost[0].cost = $cost[1].cost;                    } = { $action[1](fstate); };
ri:     reg                 { $cost[0].cost = $cost[1].cost;                    } = { $action[1](fstate); };
ri:     imm                 { $cost[0].cost = $cost[1].cost;                    } = { $action[1](fstate); };

reg:    REG                 { $cost[0].cost = 1;                                } = { $0->UseAsRegister(); };
imm:    Load(IMM)           { $cost[0].cost = 0;                                } = { $0->UseAsImmediate(); };
imm:    IMM                 { $cost[0].cost = 0;                                } = { $0->UseAsImmediate(); };
mem:    MEM                 { $cost[0].cost = 10;                               } = { $0->UseAsMemory(); };
label:  LABEL               { $cost[0].cost = 1;                                } = { };

stmt:   Ret(imm)            { $cost[0].cost = $cost[2].cost + 1;                } = {
            /*
             * IR Ret takes a register argument
             * X86 Ret takes no argument, return value is passed by %eax
             */
            $action[2](fstate);
            fstate->CreatePhysicalReg($0, RAX);
            fstate->LoadFromImm($0, $2);
            // this will record the ending in liveness range for a register
            // if the input is a register, and the register dies
            fstate->RecordLiveness($2);
            std::stringstream ss;
            ss << "jmp\t." << fstate->GetFuncName() << "End";
            std::string s = ss.str();
            fstate->AddInst(new X86Inst(s.c_str()));
        };
stmt:   Ret(reg)            { $cost[0].cost = $cost[2].cost + 1;                } = {
            /*
             * IR Ret takes a register argument
             * X86 Ret takes no argument, return value is passed by %eax
             */
            $action[2](fstate);
            fstate->CreatePhysicalReg($0, RAX);
            fstate->LoadFromReg($0, $2);
            // this will record the ending in liveness range for a register
            // if the input is a register, and the register dies
            fstate->RecordLiveness($2);
            std::stringstream ss;
            ss << "jmp\t." << fstate->GetFuncName() << "End";
            std::string s = ss.str();
            fstate->AddInst(new X86Inst(s.c_str()));
        };
mem:    Alloca(imm)         { $cost[0].cost = $cost[2].cost + 1;    } = {
            /*
             * IR Alloca takes one arguments for allocation size
             * X86 does not have correspondence for Alloca, but only uses $esp - size
             */
            $action[2](fstate);
            fstate->CreateLocal($0, 8);
            // this will record the ending in liveness range for a register
            // if the input is a register, and the register dies
            fstate->RecordLiveness($2);
            $0->UseAsMemory();
        };
reg:    Load(reg)           { $cost[0].cost = $cost[2].cost + 1;    } = {
            /*
             * IR Load takes one arguments for allocation size
             * X86 uses mov instruction, which takes two arguments
             */
            $action[2](fstate);
            fstate->AssignVirtualReg($0, $2);    // assign a virtual register to the inst
            fstate->LoadFromReg($0, $2);
            // this will record the ending in liveness range for a register
            // if the input is a register, and the register dies
            fstate->RecordLiveness($2);
            $0->UseAsRegister();
        };
reg:    Load(imm)           { $cost[0].cost = $cost[2].cost + 1;    } = {
            $action[2](fstate);
            fstate->CreateVirtualReg($0);      // assign a virtual register to the inst
            fstate->GenerateMovStmt($0, $2);
            // this will record the ending in liveness range for a register
            // if the input is a register, and the register dies
            fstate->RecordLiveness($2);
            $0->UseAsRegister();
        };
reg:    Load(mem)           { $cost[0].cost = $cost[2].cost + 1;    } = {
            $action[2](fstate);
            fstate->CreateVirtualReg($0);      // assign a virtual register to the inst
            fstate->GenerateMovStmt($0, $2);
            // this will record the ending in liveness range for a register
            // if the input is a register, and the register dies
            fstate->RecordLiveness($2);
            $0->UseAsRegister();
        };
stmt:   Store(imm, mem)      { $cost[0].cost = $cost[2].cost + $cost[3].cost;    } = {
            $action[2](fstate);
            $action[3](fstate);
            fstate->GenerateMovStmt($3, $2);
            // this will record the ending in liveness range for a register
            // if the input is a register, and the register dies
            fstate->RecordLiveness($2);
            fstate->RecordLiveness($3);
        };
stmt:   Store(reg, mem)      { $cost[0].cost = $cost[2].cost + $cost[3].cost;    } = {
            $action[2](fstate);
            $action[3](fstate);
            fstate->GenerateMovStmt($3, $2);
            // this will record the ending in liveness range for a register
            // if the input is a register, and the register dies
            fstate->RecordLiveness($2);
            fstate->RecordLiveness($3);
        };
stmt:   Store(mem, mem)      { $cost[0].cost = $cost[2].cost + $cost[3].cost;    } = {
            $action[2](fstate);
            $action[3](fstate);
            fstate->CreateVirtualReg($0->GetTreeRef());
            fstate->GenerateMovStmt($0, $2);
            fstate->GenerateMovStmt($3, $0);
            fstate->RecordLiveness($0);
        };
reg:    Add(reg, reg)       { $cost[0].cost = $cost[2].cost + $cost[3].cost + 2;    } = {
            /*
             * IR Add takes two arguments
             * X86 Add takes two argument, both operands cannot be from memory in the instruction
             */
            $action[2](fstate);
            $action[3](fstate);
            if ($2->GetRefCount() < $3->GetRefCount()) {
                fstate->AssignVirtualReg($0, $2);    // assign a virtual register to the inst
                fstate->GenerateBinaryStmt("add", $0, $3);
            } else {
                fstate->AssignVirtualReg($0, $3);    // assign a virtual register to the inst
                fstate->GenerateBinaryStmt("add", $0, $2);
            }
            // this will record the ending in liveness range for a register
            // if the input is a register, and the register dies
            fstate->RecordLiveness($2);
            fstate->RecordLiveness($3);
            $0->UseAsRegister();
        };
reg:    Add(reg, imm)       { $cost[0].cost = $cost[2].cost + $cost[3].cost + 2;    } = {
            /*
             * IR Add takes two arguments
             * X86 Add takes two argument, both operands cannot be from memory in the instruction
             */
            $action[2](fstate);
            $action[3](fstate);
            fstate->AssignVirtualReg($0, $2);    // assign a virtual register to the inst
            fstate->GenerateBinaryStmt("add", $0, $3);
            // this will record the ending in liveness range for a register
            // if the input is a register, and the register dies
            fstate->RecordLiveness($2);
            fstate->RecordLiveness($3);
            $0->UseAsRegister();
        };
reg:    Sub(reg, reg)       { $cost[0].cost = $cost[2].cost + $cost[3].cost + 2;    } = {
            /*
             * IR Sub takes two arguments
             * X86 Sub takes two argument, both operands cannot be from memory in the instruction
             */
            $action[2](fstate);
            $action[3](fstate);
            fstate->AssignVirtualReg($0, $2);    // assign a virtual register to the inst
            fstate->GenerateBinaryStmt("sub", $0, $3);
            // this will record the ending in liveness range for a register
            // if the input is a register, and the register dies
            fstate->RecordLiveness($2);
            fstate->RecordLiveness($3);
            $0->UseAsRegister();
        };
reg:    Mul(reg, reg)       { $cost[0].cost = $cost[2].cost + $cost[3].cost + 4;    } = {
            /*
             * IR Mul takes two arguments
             * X86 Mul takes two argument, both operands cannot be from memory in the instruction
             */
            $action[2](fstate);
            $action[3](fstate);
            if ($2->GetRefCount() < $3->GetRefCount()) {
                fstate->AssignVirtualReg($0, $2);    // assign a virtual register to the inst
                fstate->GenerateBinaryStmt("imul", $0, $3);
            } else {
                fstate->AssignVirtualReg($0, $3);    // assign a virtual register to the inst
                fstate->GenerateBinaryStmt("imul", $0, $2);
            }
            // this will record the ending in liveness range for a register
            // if the input is a register, and the register dies
            fstate->RecordLiveness($2);
            fstate->RecordLiveness($3);
            $0->UseAsRegister();
        };

stmt:   cond                 { $cost[0].cost = $cost[1].cost;                       } = { };
cond:   ICmp(imm, imm)       { $cost[0].cost = $cost[2].cost + $cost[3].cost;       } = { 
            $action[2](fstate);
            $action[3](fstate);
            fstate->CreateVirtualReg($0);
            fstate->GenerateMovStmt($0, $2);
            fstate->GenerateBinaryStmt("sub", $0, $3);
            // this will record the ending in liveness range for a register
            // if the input is a register, and the register dies
            fstate->RecordLiveness($2);
            fstate->RecordLiveness($3);
        };
cond:   ICmp(reg, imm)       { $cost[0].cost = $cost[2].cost + $cost[3].cost;       } = { 
            $action[2](fstate);
            $action[3](fstate);
            fstate->AssignVirtualReg($0, $2);    // assign a virtual register to the inst
            fstate->GenerateBinaryStmt("cmp", $0, $3, false);
            // this will record the ending in liveness range for a register
            // if the input is a register, and the register dies
            fstate->RecordLiveness($2);
            fstate->RecordLiveness($3);
        };
stmt:   Br(label, DUMMY, DUMMY)   { $cost[0].cost = $cost[2].cost + 5; } = {
            fstate->AddInst(new X86Inst("jmp",
                    new X86Operand(fstate, OP_TYPE::X86Label, $2->GetValue())
            ));
            $action[2](fstate);
        };
stmt:   Br(cond, label, label)   { $cost[0].cost = $cost[2].cost + $cost[3].cost + $cost[4].cost + 5; } = {
            using namespace llvm;

            $action[2](fstate);
            CmpInst *inst = dyn_cast<CmpInst>($2->GetInst());
            assert(inst && "cond node must have instruction attached");

            std::string op;
            CmpInst::Predicate pred = inst->getPredicate();
            switch (pred) {
                case CmpInst::Predicate::ICMP_EQ:
                    // equal
                    op = "je";
                    break;
                case CmpInst::Predicate::ICMP_NE:
                    // not equal
                    op = "jne";
                    break;
                case CmpInst::Predicate::ICMP_UGT:
                    // unsigned greater than
                    op = "ja";
                    break;
                case CmpInst::Predicate::ICMP_UGE:
                    // unsigned greater or equal
                    op = "jae";
                    break;
                case CmpInst::Predicate::ICMP_ULT:
                    // unsigned less than
                    op = "jb";
                    break;
                case CmpInst::Predicate::ICMP_ULE:
                    // unsigned less or equal
                    op = "jbe";
                    break;
                case CmpInst::Predicate::ICMP_SGT:
                    // signed greater than
                    op = "jg";
                    break;
                case CmpInst::Predicate::ICMP_SGE:
                    // signed greater or equal
                    op = "jge";
                    break;
                case CmpInst::Predicate::ICMP_SLT:
                    // signed less than
                    op = "jl";
                    break;
                case CmpInst::Predicate::ICMP_SLE:
                    // signed less or equal
                    op = "jle";
                    break;
                default:
                    assert(false && "FP TYPES NOT SUPPORTED!");
            }
            fstate->AddInst(new X86Inst(op.c_str(),
                    new X86Operand(fstate, OP_TYPE::X86Label, $3->GetValue())
            ));

            $action[4](fstate);
            $action[3](fstate);
        };
reg:    Call(args)               { $cost[0].cost = $cost[2].cost + 5; } = {
            $action[2](fstate, 0);
            std::stringstream ss;
            ss << "call\t" << $0->GetFuncName();
            std::string s = ss.str();
            fstate->AddInst(new X86Inst(s.c_str()));
            fstate->CreatePhysicalReg($0, RAX);
        };
args:   NOARGS                  { $cost[0].cost = 0;                  } = {
            // for args tree termination
        };
args:   ARGS(value, args)        { $cost[0].cost = $cost[2].cost + $cost[3].cost; } = {
            $action[2](fstate);
            $action[3](fstate, n + 1);
            if (n < 6) {
                $0->SetValue(params_regs[n]);
                $0->UseAsPhysicalRegister();
                fstate->GenerateMovStmt($0, $2);
            } else {
                // more than 6 argments should be pushed on stack in reversed order
                fstate->GeneratePushStmt($2);
            }
        };
reg:    Trunc(reg)              { $cost[0].cost = $cost[2].cost + 3;              } = {
            $action[2](fstate);
            fstate->CreateVirtualReg($0);
            fstate->LoadFromReg($0, $2);
        };
mem:    GetElementPtr(ri, ri, imm)    { $cost[0].cost = $cost[2].cost + $cost[3].cost + $cost[4].cost + 5; } = {
            $action[2](fstate);
            $action[3](fstate);
            $action[4](fstate);
            X86Operand *ptr = new X86Operand(fstate, OP_TYPE::X86Mem,
                $2->AsX86Operand(fstate),         // base
                nullptr, // $3->AsX86Operand(fstate),         // displacement
                0,
                8 * $4->GetValue().val.i64s           // offset
            );
            $0->SetX86Operand(ptr);
        };
mem:    GetElementPtr(mem, ri, imm)    { $cost[0].cost = $cost[2].cost + $cost[3].cost + $cost[4].cost + 5; } = {
            $action[2](fstate);
            $action[3](fstate);
            $action[4](fstate);

            Tree *t1 = new Tree(REG);
            fstate->CreateVirtualReg(t1);

            X86Operand *ptr = new X86Operand(fstate, OP_TYPE::X86Mem,
                t1->AsX86Operand(fstate),          // base
                nullptr, // $3->AsX86Operand(fstate),         // displacement
                0,
                8 * $4->GetValue().val.i64s           // offset
            );
            $0->SetX86Operand(ptr);
        };
reg:    BitCast(rm)             { $cost[0].cost = $cost[2].cost + 1; } = {
            $action[2](fstate);
            fstate->CreateVirtualReg($0);      // assign a virtual register to the inst
            fstate->GenerateMovStmt($0, $2);
        };
%%
#include "llc_olive_helper.cxx"
