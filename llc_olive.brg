%{
#include "llc_olive_helper.h"
%}

%term DUMMY=0
%term Ret=1 Br=2 Switch=3 IndirectBr=4 Invoke=5 Resume=6 Unreachable=7 CleanupRet=8 CatchRet=9 CatchSwitch=10
%term Add=11 FAdd=12 Sub=13 FSub=14 Mul=15 FMul=16 UDiv=17 SDiv=18 FDiv=19 URem=20 SRem=21 FRem=22
%term Shl=23 LShr=24 AShr=25 And=26 Or=27 Xor=28
%term Alloca=29 Load=30 Store=31 GetElementPtr=32 Fence=33 AtomicCmpXchg=34 AtomicRMW=35
%term Trunc=36 ZExt=37 SExt=38 FPToUI=39 FPToSI=40 UIToFP=41 SIToFP=42 FPTrunc=43 FPExt=44 PtrToInt=45 IntToPtr=46 BitCast=47 AddrSpaceCast=48
%term CleanupPad=49 CatchPad=50
%term ICmp=51 FCmp=52 PHI=53 Call=54 Select=55 UserOp1=56 UserOp2=57 VAArg=58 ExtractElement=59 InsertElement=60 ShuffleVector=61 ExtractValue=62 InsertValue=63 LandingPad=64
%term REG=65 IMM=66 MEM=67 LABEL=68 ARGS=69 NOARGS=70 PTR=71 GlobalValue=72 PHIInst=73

%declare<void> stmt     <FUNCTION_STATE fstate>;
%declare<void> value    <FUNCTION_STATE fstate>;
%declare<void> ri       <FUNCTION_STATE fstate>;
%declare<void> rm       <FUNCTION_STATE fstate>;
%declare<void> rim      <FUNCTION_STATE fstate>;
%declare<void> reg      <FUNCTION_STATE fstate>;
%declare<void> imm      <FUNCTION_STATE fstate>;
%declare<void> mem      <FUNCTION_STATE fstate>;
%declare<void> ptr      <FUNCTION_STATE fstate>;
%declare<void> cond     <FUNCTION_STATE fstate>;
%declare<void> label    <FUNCTION_STATE fstate>;
%declare<void> args     <FUNCTION_STATE fstate, int n>;
%%

stmt:   reg                 { return 1;                                         } = { $action[1](fstate); /*fstate->RecordLiveness($1);*/ };
stmt:   mem                 { return 1;                                         } = { $action[1](fstate); /*fstate->RecordLiveness($1);*/ };

value:  reg                 { $cost[0].cost = $cost[1].cost;                    } = { $action[1](fstate); /*fstate->RecordLiveness($1);*/ };
value:  imm                 { $cost[0].cost = $cost[1].cost;                    } = { $action[1](fstate); /*fstate->RecordLiveness($1);*/ };
value:  mem                 { $cost[0].cost = $cost[1].cost;                    } = { $action[1](fstate); /*fstate->RecordLiveness($1);*/ };

reg:    ptr                 { $cost[0].cost = $cost[1].cost;                    } = { $action[1](fstate); /*fstate->RecordLiveness($1);*/ };
ri:     reg                 { $cost[0].cost = $cost[1].cost;                    } = { $action[1](fstate); /*fstate->RecordLiveness($1);*/ };
ri:     imm                 { $cost[0].cost = $cost[1].cost;                    } = { $action[1](fstate); /*fstate->RecordLiveness($1);*/ };

rm:     reg                 { $cost[0].cost = $cost[1].cost;                    } = { $action[1](fstate); /*fstate->RecordLiveness($1);*/ };
rm:     mem                 { $cost[0].cost = $cost[1].cost;                    } = { $action[1](fstate); /*fstate->RecordLiveness($1);*/ };

rim:    reg                 { $cost[0].cost = $cost[1].cost;                    } = { $action[1](fstate); /*fstate->RecordLiveness($1);*/ };
rim:    imm                 { $cost[0].cost = $cost[1].cost;                    } = { $action[1](fstate); /*fstate->RecordLiveness($1);*/ };
rim:    mem                 { $cost[0].cost = $cost[1].cost;                    } = { $action[1](fstate); /*fstate->RecordLiveness($1);*/ };

reg:    REG                 { $cost[0].cost = 1;                                } = { $0->UseAsRegister();  /*fstate->RecordLiveness($1);*/ };
imm:    Load(IMM)           { $cost[0].cost = 0;                                } = { $0->UseAsImmediate(); /*                           */ };
imm:    IMM                 { $cost[0].cost = 0;                                } = { $0->UseAsImmediate(); /*fstate->RecordLiveness($1);*/ };
mem:    MEM                 { $cost[0].cost = 10;                               } = { $0->UseAsMemory();    /*fstate->RecordLiveness($1);*/ };
mem:    GlobalValue         { $cost[0].cost = 1;                                } = { };
label:  LABEL               { $cost[0].cost = 1;                                } = { };

reg:    PHI(_)              { $cost[0].cost = 1;                                } = {
            // PHI is special because its register is pre-allocated
            // ri should have already been computed
            fstate->RecordLiveStart($0);     // start recording liveness for phi
            fstate->GenerateMovStmt($0, $2);
            fstate->RecordLiveness($2);
        };
stmt:   Ret(ri)            { $cost[0].cost = $cost[2].cost + 1;                } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);
            /*
             * IR Ret takes a register argument
             * X86 Ret takes no argument, return value is passed by %eax
             */
            $action[2](fstate);
            fstate->CreatePhysicalReg($0, RAX);
            fstate->GenerateMovStmt($0, $2);

            // this will record the ending in liveness range for a register
            // if the input is a register, and the register dies
            fstate->RecordLiveness($2);
            std::stringstream ss;
            ss << "jmp \t.LFE" << fstate->GetFunctionID();
            std::string s = ss.str();
            fstate->GenerateStmt(s.c_str());
        };
mem:    Alloca(imm)         { $cost[0].cost = $cost[2].cost + 1;    } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);
            /*
             * IR Alloca takes one arguments for allocation size
             * X86 does not have correspondence for Alloca, but only uses $esp - size
             */
            using namespace llvm;
            llvm::AllocaInst *inst = dyn_cast<llvm::AllocaInst>($1->GetInst());
            assert(inst && "llvm inst must be alloca inst");

            $action[2](fstate);

            Type *type = inst->getAllocatedType();
            int type_size = GetTypeSize(type);

            if (inst->isArrayAllocation()) {
                llvm::ConstantInt* array_size = dyn_cast<llvm::ConstantInt>(inst->getArraySize());
                int elems = array_size->getZExtValue();
                fstate->CreateLocal($0, type_size * elems);     // reserve the space for array elements
            }
            else if (type->isArrayTy()) {
                ArrayType *arr_ty = dyn_cast<ArrayType>(type);
                int elems = arr_ty->getNumElements();
                fstate->CreateLocal($0, type_size * elems);     // reserve the space for array elements
            }
            else if (type->isStructTy()) {
                assert(false && "struct not supported");
            }
            else {
                fstate->CreateLocal($0, type_size);
            }

            // this will record the ending in liveness range for a register
            // if the input is a register, and the register dies
            fstate->RecordLiveness($2);
            $0->UseAsMemory();
        };
reg:    Load(ri)            { $cost[0].cost = $cost[2].cost + 1;    } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);
            /*
             * IR Load takes one arguments for allocation size
             * X86 uses mov instruction, which takes two arguments
             */
            $action[2](fstate);
            fstate->AssignVirtualReg($0, $2);    // assign a virtual register to the inst
            fstate->GenerateMovStmt($0, $2);
            // this will record the ending in liveness range for a register
            // if the input is a register, and the register dies
            fstate->RecordLiveness($2);
            $0->UseAsRegister();
        };
reg:    Load(mem)           { $cost[0].cost = $cost[2].cost + 5;    } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);

            $action[2](fstate);
            fstate->CreateVirtualReg($0);      // assign a virtual register to the inst
            fstate->GenerateMovStmt($0, $2);
            // this will record the ending in liveness range for a register
            // if the input is a register, and the register dies
            fstate->RecordLiveness($2);
            $0->UseAsRegister();
        };
stmt:   Store(ri, mem)      { if ($2->IsPointer()) return 0; else $cost[0].cost = $cost[2].cost + $cost[3].cost;    } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);

            $action[2](fstate);
            $action[3](fstate);
            fstate->GenerateMovStmt($3, $2, $3->GetSuffix());
            // this will record the ending in liveness range for a register
            // if the input is a register, and the register dies
            fstate->RecordLiveness($2);
            fstate->RecordLiveness($3);
        };
stmt:   Store(mem, mem)      { $cost[0].cost = $cost[2].cost + $cost[3].cost;    } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);

            $action[2](fstate);
            $action[3](fstate);

            Tree *t1 = (new Tree(REG))->GetTreeRef();
            fstate->CreateVirtualReg(t1);

            fstate->GenerateMovStmt(t1, $2, $3->GetSuffix());
            fstate->GenerateMovStmt($3, t1, $3->GetSuffix());

            fstate->RecordLiveness(t1);
            fstate->RecordLiveness($2);
            fstate->RecordLiveness($3);
        };
stmt:   Store(ri, ptr)      { $cost[0].cost = $cost[2].cost + $cost[3].cost;    } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);

            $action[2](fstate);
            $action[3](fstate);

            if ($2->IsPointer()) {
                // llvm::errs() << "Store ptr to ptr!\n";
                // fstate->LoadEffectiveAddress($3, $2);
                $2->SetX86Operand($3->AsX86Operand(fstate));
            }
            else {
                // llvm::errs() << "Store ri to ptr!\n";
                fstate->GenerateMovStmt($3, $2, $3->GetSuffix());
            }

            // this will record the ending in liveness range for a register
            // if the input is a register, and the register dies
            fstate->RecordLiveness($2);
            fstate->RecordLiveness($3);
        };
stmt:   Store(mem, ptr)      { $cost[0].cost = $cost[2].cost + $cost[3].cost;    } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);

            $action[2](fstate);
            $action[3](fstate);

            Tree *t1 = (new Tree(REG))->GetTreeRef();
            fstate->CreateVirtualReg(t1);

            // llvm::errs() << "Store mem to ptr!\n";
            fstate->GenerateMovStmt(t1, $2, $3->GetSuffix());
            fstate->GenerateMovStmt($3, t1, $3->GetSuffix());

            fstate->RecordLiveness(t1);
            fstate->RecordLiveness($2);
            fstate->RecordLiveness($3);
        };
stmt:   Store(ptr, mem)      { $cost[0].cost = $cost[2].cost + $cost[3].cost;    } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);

            $action[2](fstate);
            $action[3](fstate);

            // using namespace llvm;
            // $1->GetInst()->print(errs()); errs() << "\n";
            // Value *v = $1->GetInst()->getOperand(0);

            Tree *t1 = (new Tree(REG))->GetTreeRef();
            fstate->CreateVirtualReg(t1);

            fstate->LoadEffectiveAddress($3, $2);

            fstate->RecordLiveness(t1);
            fstate->RecordLiveness($2);
            fstate->RecordLiveness($3);
        };
imm:    Add(imm, imm)       { $cost[0].cost = 0;    } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);

            $action[2](fstate);
            $action[3](fstate);

            // compute the arithmetic operation
            $0->SetValue($2->GetValue() + $3->GetValue());

            fstate->RecordLiveness($2);
            fstate->RecordLiveness($3);
            $0->UseAsImmediate();
        };
reg:    Add(imm, imm)       { $cost[0].cost = 1;    } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);

            $action[2](fstate);
            $action[3](fstate);
            fstate->CreateVirtualReg($0);

            // compute the arithmetic operation
            Tree *t1 = (new Tree(IMM))->GetTreeRef();
            t1->SetValue($2->GetValue() + $3->GetValue());
            fstate->GenerateMovStmt($0, t1, $0->GetSuffix());

            fstate->RecordLiveness($2);
            fstate->RecordLiveness($3);
            $0->UseAsRegister();
        };
reg:    Add(reg, rim)       { $cost[0].cost = $cost[2].cost + $cost[3].cost + 2;    } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);
            /*
             * IR Add takes two arguments
             * X86 Add takes two argument, both operands cannot be from memory in the instruction
             */
            $action[2](fstate);
            $action[3](fstate);
            fstate->AssignVirtualReg($0, $2);    // assign a virtual register to the inst
            fstate->GenerateBinaryStmt("add", $0, $3);
            // this will record the ending in liveness range for a register
            // if the input is a register, and the register dies
            fstate->RecordLiveness($2);
            fstate->RecordLiveness($3);
            $0->UseAsRegister();
        };
reg:    Add(ri, reg)       { $cost[0].cost = $cost[2].cost + $cost[3].cost + 2;    } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);
            /*
             * IR Add takes two arguments
             * X86 Add takes two argument, both operands cannot be from memory in the instruction
             */
            $action[2](fstate);
            $action[3](fstate);
            fstate->AssignVirtualReg($0, $3);    // assign a virtual register to the inst
            fstate->GenerateBinaryStmt("add", $0, $2);
            // this will record the ending in liveness range for a register
            // if the input is a register, and the register dies
            fstate->RecordLiveness($2);
            fstate->RecordLiveness($3);
            $0->UseAsRegister();
        };
imm:    Sub(imm, imm)       { $cost[0].cost = 0;    } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);

            $action[2](fstate);
            $action[3](fstate);

            // compute the arithmetic operation
            $0->SetValue($2->GetValue() - $3->GetValue());

            fstate->RecordLiveness($2);
            fstate->RecordLiveness($3);
            $0->UseAsImmediate();
        };
reg:    Sub(imm, imm)       { $cost[0].cost = 1;    } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);

            $action[2](fstate);
            $action[3](fstate);
            fstate->CreateVirtualReg($0);

            // compute the arithmetic operation
            Tree *t1 = (new Tree(IMM))->GetTreeRef();
            t1->SetValue($2->GetValue() - $3->GetValue());
            fstate->GenerateMovStmt($0, t1);

            fstate->RecordLiveness($2);
            fstate->RecordLiveness($3);
            $0->UseAsRegister();
        };
reg:    Sub(reg, rim)      { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1;    } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);
            /*
             * IR Sub takes two arguments
             * X86 Sub takes two argument, both operands cannot be from memory in the instruction
             */
            $action[2](fstate);
            $action[3](fstate);
            fstate->AssignVirtualReg($0, $2);    // assign a virtual register to the inst
            fstate->GenerateBinaryStmt("sub", $0, $3);
            // this will record the ending in liveness range for a register
            // if the input is a register, and the register dies
            fstate->RecordLiveness($2);
            fstate->RecordLiveness($3);
            $0->UseAsRegister();
        };
reg:    Sub(imm, reg)      { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1;    } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);
            /*
             * IR Sub takes two arguments
             * X86 Sub takes two argument, both operands cannot be from memory in the instruction
             */
            $action[2](fstate);
            $action[3](fstate);
            fstate->CreateVirtualReg($0);
            fstate->GenerateMovStmt($0, $2);
            fstate->GenerateBinaryStmt("sub", $0, $3);
            // this will record the ending in liveness range for a register
            // if the input is a register, and the register dies
            fstate->RecordLiveness($2);
            fstate->RecordLiveness($3);
            $0->UseAsRegister();
        };
imm:    Mul(imm, imm)       { $cost[0].cost = 0;    } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);

            $action[2](fstate);
            $action[3](fstate);

            // compute the arithmetic operation
            $0->SetValue($2->GetValue() * $3->GetValue());

            fstate->RecordLiveness($2);
            fstate->RecordLiveness($3);
            $0->UseAsImmediate();
        };
reg:    Mul(imm, imm)       { $cost[0].cost = 2;    } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);

            $action[2](fstate);
            $action[3](fstate);
            fstate->CreateVirtualReg($0);

            // compute the arithmetic operation
            Tree *t1 = (new Tree(IMM))->GetTreeRef();
            t1->SetValue($2->GetValue() * $3->GetValue());
            fstate->GenerateMovStmt($0, t1);

            fstate->RecordLiveness($2);
            fstate->RecordLiveness($3);
            $0->UseAsRegister();
        };
reg:    Mul(reg, rim)      { $cost[0].cost = $cost[2].cost + $cost[3].cost + 2;    } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);
            /*
             * IR Mul takes two arguments
             * X86 Mul takes two argument, both operands cannot be from memory in the instruction
             */
            $action[2](fstate);
            $action[3](fstate);
            fstate->AssignVirtualReg($0, $2);    // assign a virtual register to the inst
            fstate->GenerateBinaryStmt("imul", $0, $3);
            // this will record the ending in liveness range for a register
            // if the input is a register, and the register dies
            fstate->RecordLiveness($2);
            fstate->RecordLiveness($3);
            $0->UseAsRegister();
        };
reg:    Mul(ri, reg)       { $cost[0].cost = $cost[2].cost + $cost[3].cost + 2;    } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);
            /*
             * IR Mul takes two arguments
             * X86 Mul takes two argument, both operands cannot be from memory in the instruction
             */
            $action[2](fstate);
            $action[3](fstate);
            // std::cerr << "IS REG A PHYSICAL REG? " << $3->IsPhysicalReg() << std::endl;
            fstate->AssignVirtualReg($0, $3);    // assign a virtual register to the inst
            fstate->GenerateBinaryStmt("imul", $0, $2);
            // this will record the ending in liveness range for a register
            // if the input is a register, and the register dies
            fstate->RecordLiveness($2);
            fstate->RecordLiveness($3);
            $0->UseAsRegister();
        };
imm:    UDiv(imm, imm)       { $cost[0].cost = 0;    } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);

            $action[2](fstate);
            $action[3](fstate);

            // compute the arithmetic operation
            $0->SetValue($2->GetValue() / $3->GetValue());

            fstate->RecordLiveness($2);
            fstate->RecordLiveness($3);
            $0->UseAsImmediate();
        };
reg:    UDiv(imm, imm)       { $cost[0].cost = 2;    } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);

            $action[2](fstate);
            $action[3](fstate);
            fstate->CreateVirtualReg($0);

            // compute the arithmetic operation
            Tree *t1 = (new Tree(IMM))->GetTreeRef();
            t1->SetValue($2->GetValue() / $3->GetValue());
            fstate->GenerateMovStmt($0, t1);

            fstate->RecordLiveness($2);
            fstate->RecordLiveness($3);
            $0->UseAsRegister();
        };
reg:    UDiv(rm, rm)       { $cost[0].cost = $cost[2].cost + $cost[3].cost + 4;    } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);
            /*
             * IR Mul takes two arguments
             * X86 Mul takes one argument, perform %rax = %rax / src
             */
            $action[2](fstate);
            $action[3](fstate);

            fstate->CreatePhysicalReg($0, RAX);         // the result is stored in %rax
            fstate->GenerateMovStmt($0, $2);            // move one of the operands to %rax
            fstate->GenerateStmt("cqto");               // sign extension
            fstate->GenerateUnaryStmt("div", $3);       // generate div instruction

            fstate->RecordLiveness($2);
            fstate->RecordLiveness($3);
            $0->UseAsRegister();
        };
imm:    SDiv(imm, imm)       { $cost[0].cost = 0;    } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);

            $action[2](fstate);
            $action[3](fstate);

            // compute the arithmetic operation
            $0->SetValue($2->GetValue() / $3->GetValue());

            fstate->RecordLiveness($2);
            fstate->RecordLiveness($3);
            $0->UseAsImmediate();
        };
reg:    SDiv(imm, imm)       { $cost[0].cost = 2;    } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);

            $action[2](fstate);
            $action[3](fstate);
            fstate->CreateVirtualReg($0);

            // compute the arithmetic operation
            Tree *t1 = (new Tree(IMM))->GetTreeRef();
            t1->SetValue($2->GetValue() / $3->GetValue());
            fstate->GenerateMovStmt($0, t1);

            fstate->RecordLiveness($2);
            fstate->RecordLiveness($3);
            $0->UseAsRegister();
        };
reg:    SDiv(rm, rm)       { $cost[0].cost = $cost[2].cost + $cost[3].cost + 4;    } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);
            /*
             * IR Mul takes two arguments
             * X86 Mul takes one argument, perform %rax = %rax / src
             */
            $action[2](fstate);
            $action[3](fstate);

            fstate->CreatePhysicalReg($0, RAX);         // the result is stored in %rax
            fstate->GenerateMovStmt($0, $2);            // move one of the operands to %rax
            fstate->GenerateStmt("cqto");               // sign extension
            fstate->GenerateUnaryStmt("idiv", $3);      // generate div instruction

            fstate->RecordLiveness($2);
            fstate->RecordLiveness($3);
            $0->UseAsRegister();
        };
reg:    UDiv(rm, imm)       { $cost[0].cost = $cost[2].cost + $cost[3].cost + 4;    } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);
            /*
             * IR Mul takes two arguments
             * X86 Mul takes one argument, perform %rax = %rax / src
             */
            $action[2](fstate);
            $action[3](fstate);

            fstate->CreatePhysicalReg($0, RAX);         // the result is stored in %rax
            fstate->GenerateMovStmt($0, $2);            // move one of the operands to %rax

            Tree *t1 = (new Tree(REG))->GetTreeRef();
            fstate->CreateVirtualReg(t1);
            fstate->GenerateMovStmt(t1, $3);            // move one of the operands to new register

            fstate->GenerateStmt("cqto");               // sign extension
            fstate->GenerateUnaryStmt("div", t1);       // generate div instruction

            fstate->RecordLiveness(t1);
            fstate->RecordLiveness($2);
            fstate->RecordLiveness($2);
            fstate->RecordLiveness($3);
            $0->UseAsRegister();
        };
reg:    SDiv(rm, imm)       { $cost[0].cost = $cost[2].cost + $cost[3].cost + 4;    } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);
            /*
             * IR Mul takes two arguments
             * X86 Mul takes one argument, perform %rax = %rax / src
             */
            $action[2](fstate);
            $action[3](fstate);

            fstate->CreatePhysicalReg($0, RAX);         // the result is stored in %rax
            fstate->GenerateMovStmt($0, $2);            // move one of the operands to %rax

            Tree *t1 = (new Tree(REG))->GetTreeRef();
            fstate->CreateVirtualReg(t1);
            fstate->GenerateMovStmt(t1, $3);            // move one of the operands to new register

            fstate->GenerateStmt("cqto");               // sign extension
            fstate->GenerateUnaryStmt("idiv", t1);       // generate div instruction

            fstate->RecordLiveness(t1);
            fstate->RecordLiveness($2);
            fstate->RecordLiveness($3);
            $0->UseAsRegister();
        };

stmt:   cond                 { $cost[0].cost = $cost[1].cost;                       } = { $action[1](fstate); };
cond:   ICmp(imm, imm)       { $cost[0].cost = $cost[2].cost + $cost[3].cost;       } = { 
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);

            $action[2](fstate);
            $action[3](fstate);
            fstate->CreateVirtualReg($0);
            fstate->GenerateMovStmt($0, $2);
            fstate->GenerateBinaryStmt("cmp ", $0, $3);
            // this will record the ending in liveness range for a register
            // if the input is a register, and the register dies
            fstate->RecordLiveness($2);
            fstate->RecordLiveness($3);
        };
cond:   ICmp(reg, imm)       { $cost[0].cost = $cost[2].cost + $cost[3].cost;       } = { 
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);

            $action[2](fstate);
            $action[3](fstate);
            fstate->AssignVirtualReg($0, $2);    // assign a virtual register to the inst
            fstate->GenerateBinaryStmt("cmp ", $0, $3);
            // this will record the ending in liveness range for a register
            // if the input is a register, and the register dies
            fstate->RecordLiveness($2);
            fstate->RecordLiveness($3);
        };
cond:   ICmp(reg, reg)       { $cost[0].cost = $cost[2].cost + $cost[3].cost;       } = { 
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);

            $action[2](fstate);
            $action[3](fstate);
            fstate->AssignVirtualReg($0, $2);    // assign a virtual register to the inst
            fstate->GenerateBinaryStmt("cmp ", $0, $3);
            // this will record the ending in liveness range for a register
            // if the input is a register, and the register dies
            fstate->RecordLiveness($2);
            fstate->RecordLiveness($3);
        };
stmt:   Br(label, DUMMY, DUMMY)   { $cost[0].cost = $cost[2].cost + 5; } = {
            fstate->GenerateUnaryStmt("jmp ", $2, false);

            using namespace llvm;
            BranchInst *inst = dyn_cast<BranchInst>($0->GetInst());
            BasicBlock *bb = inst->getSuccessor(0);
            std::stringstream ss;
            ss << "# ---- JMP to " << bb->getName().str();
            std::string s = ss.str();
            fstate->AddInst(new X86Inst(s.c_str()));

            $action[2](fstate);
        };
stmt:   Br(cond, label, label)   { $cost[0].cost = $cost[2].cost + $cost[3].cost + $cost[4].cost + 5; } = {
            using namespace llvm;

            $action[2](fstate);
            CmpInst *inst = dyn_cast<CmpInst>($2->GetInst());
            assert(inst && "cond node must have instruction attached");

            /**
             * As our comparison is reversed, we need to reverse the comparison predicate
             * */
            std::string op;
            CmpInst::Predicate pred = inst->getPredicate();
            switch (pred) {
                case CmpInst::Predicate::ICMP_EQ:
                    // equal
                    op = "jne ";
                    break;
                case CmpInst::Predicate::ICMP_NE:
                    // not equal
                    op = "je  ";
                    break;
                case CmpInst::Predicate::ICMP_UGT:
                    // unsigned greater than
                    op = "jbe ";
                    break;
                case CmpInst::Predicate::ICMP_UGE:
                    // unsigned greater or equal
                    op = "jb  ";
                    break;
                case CmpInst::Predicate::ICMP_ULT:
                    // unsigned less than
                    op = "jae ";
                    break;
                case CmpInst::Predicate::ICMP_ULE:
                    // unsigned less or equal
                    op = "ja  ";
                    break;
                case CmpInst::Predicate::ICMP_SGT:
                    // signed greater than
                    op = "jle ";
                    break;
                case CmpInst::Predicate::ICMP_SGE:
                    // signed greater or equal
                    op = "jl  ";
                    break;
                case CmpInst::Predicate::ICMP_SLT:
                    // signed less than
                    op = "jge ";
                    break;
                case CmpInst::Predicate::ICMP_SLE:
                    // signed less or equal
                    op = "jg  ";
                    break;
                default:
                    assert(false && "FP TYPES NOT SUPPORTED!");
            }
            fstate->GenerateUnaryStmt(op.c_str(), $3, false);

            $action[4](fstate);
            $action[3](fstate);
        };
reg:    Call(args)               { $cost[0].cost = $cost[2].cost + 5; } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);

            int num_args = std::min(6, fstate->GetNumArgs());

            fstate->AddInst(new X86Inst("call-begin", true));

            // Need to preserve caller_saved_regs
            for (int i = 1; i < 1 + num_args; i++)
                fstate->GeneratePushStmt(caller_saved_regs[i]);

            $action[2](fstate, 0);

            std::stringstream ss;
            ss << "call\t" << $0->GetFuncName();
            std::string s = ss.str();
            fstate->GenerateStmt(s.c_str());

            fstate->CreatePhysicalReg($0, RAX);
            $0->UseAsPhysicalRegister();

            // Need to restore caller_saved_regs
            for (int i = num_args; i > 0; i--)
                fstate->GeneratePopStmt(caller_saved_regs[i]);

            fstate->AddInst(new X86Inst("call-end", true));
        };
args:   NOARGS                  { $cost[0].cost = 0;                  } = {
            // for args tree termination
        };
args:   ARGS(value, args)        { $cost[0].cost = $cost[2].cost + $cost[3].cost; } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);

            if (n < 6) {
                // arguments in registers are added in order
                $action[2](fstate);

                $0->SetValue(params_regs[n]);
                $0->UseAsPhysicalRegister();
                if (!$2->IsPointer()) fstate->GenerateMovStmt($0, $2);
                else                  fstate->LoadEffectiveAddress($0, $2);
                fstate->RecordLiveness($2);

                $action[3](fstate, n + 1);
            } else {
                // arguments in memory are added in reversed order
                // more than 6 argments should be pushed on stack in reversed order
                $action[3](fstate, n + 1);
                $action[2](fstate);
                fstate->GeneratePushStmt($2);
                fstate->RecordLiveness($2);
            }
        };
reg:    Trunc(reg)              { $cost[0].cost = $cost[2].cost + 3;              } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);

            $action[2](fstate);
            fstate->CreateVirtualReg($0);
            fstate->GenerateMovStmt($0, $2);
            fstate->RecordLiveness($2);
        };
reg:    SExt(reg)              { $cost[0].cost = $cost[2].cost + 3;              } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);

            $action[2](fstate);
            fstate->CreateVirtualReg($0);
            fstate->GenerateMovStmt($0, $2);
            fstate->RecordLiveness($2);
        };
reg:    ZExt(reg)              { $cost[0].cost = $cost[2].cost + 3;              } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);

            $action[2](fstate);
            fstate->CreateVirtualReg($0);
            fstate->GenerateMovStmt($0, $2);
            fstate->RecordLiveness($2);
        };
reg:    BitCast(reg)            { $cost[0].cost = $cost[2].cost + 1; } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);

            // std::cerr << "=============BitCast REG REF " << $0->GetRefCount() << std::endl;
            $action[2](fstate);
            fstate->AssignVirtualReg($0, $2);    // assign a virtual register to the inst
            fstate->RecordLiveness($2);
            $0->UseAsRegister();
        };
reg:    BitCast(mem)            { $cost[0].cost = $cost[2].cost + 1; } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);

            // std::cerr << "-------------BitCast REG REF " << $0->GetRefCount() << std::endl;
            $action[2](fstate);
            fstate->CreateVirtualReg($0);    // assign a virtual register to the inst
            fstate->LoadEffectiveAddress($0, $2);
            $0->UseAsRegister();
        };
ptr:    GetElementPtr(reg, _, imm)    { $cost[0].cost = $cost[2].cost + $cost[4].cost + 5; } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);

            // get size of array elements
            using namespace llvm;
            GetElementPtrInst *inst = dyn_cast<GetElementPtrInst>($1->GetInst());
            assert(inst && "GetElementPtr must be not null");
            int size = GetTypeSize(inst->getSourceElementType());

            $action[2](fstate);
            $action[4](fstate);

            X86Operand *ptr = new X86Operand(fstate, OP_TYPE::X86Mem,
                $2->AsX86Operand(fstate),         // base
                0,
                0,
                size * $4->GetValue().val.i64s    // offset
            );
            $0->SetX86Operand(ptr);
            $0->SetSuffix(GetTypeSuffix(inst->getSourceElementType()));

            fstate->RecordLiveness($2);
            fstate->RecordLiveness($4);
            $0->UseAsMemory();
            $0->UseAsPtr();
        };
ptr:    GetElementPtr(reg, _, reg)    { $cost[0].cost = $cost[2].cost + $cost[4].cost + 5; } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);

            // get size of array elements
            using namespace llvm;
            GetElementPtrInst *inst = dyn_cast<GetElementPtrInst>($1->GetInst());
            assert(inst && "GetElementPtr must be not null");
            int size = GetTypeSize(inst->getSourceElementType());

            $action[2](fstate);
            $action[4](fstate);

            X86Operand *ptr = new X86Operand(fstate, OP_TYPE::X86Mem,
                $2->AsX86Operand(fstate),         // base
                $3->AsX86Operand(fstate),         // index
                size,                             // element size
                0
            );
            $0->SetX86Operand(ptr);
            $0->SetSuffix(GetTypeSuffix(inst->getSourceElementType()));

            fstate->RecordLiveness($2);
            fstate->RecordLiveness($4);
            $0->UseAsMemory();
            $0->UseAsPtr();
        };
ptr:    GetElementPtr(mem, _, imm)    { $cost[0].cost = $cost[2].cost + $cost[4].cost + 5; } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);

            // get size of array elements
            using namespace llvm;
            GetElementPtrInst *inst = dyn_cast<GetElementPtrInst>($1->GetInst());
            assert(inst && "GetElementPtr must be not null");
            int size = GetTypeSize(inst->getSourceElementType());

            $action[2](fstate);
            $action[4](fstate);

            Tree *t1 = (new Tree(REG))->GetTreeRef();
            fstate->CreateVirtualReg(t1);
            fstate->LoadEffectiveAddress(t1, $2);

            X86Operand *ptr = new X86Operand(fstate, OP_TYPE::X86Mem,
                t1->AsX86Operand(fstate),         // base
                0,
                0,
                size * $4->GetValue().val.i64s    // offset
            );
            $0->SetX86Operand(ptr);
            $0->SetSuffix(GetTypeSuffix(inst->getSourceElementType()));

            fstate->RecordLiveness(t1);
            fstate->RecordLiveness($2);
            fstate->RecordLiveness($4);
            $0->UseAsMemory();
            $0->UseAsPtr();
        };
ptr:    GetElementPtr(mem, _, reg)    { $cost[0].cost = $cost[2].cost + $cost[4].cost + 5; } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);

            // get size of array elements
            using namespace llvm;
            GetElementPtrInst *inst = dyn_cast<GetElementPtrInst>($1->GetInst());
            assert(inst && "GetElementPtr must be not null");
            int size = GetTypeSize(inst->getSourceElementType());

            $action[2](fstate);
            $action[4](fstate);

            Tree *t1 = (new Tree(REG))->GetTreeRef();
            fstate->CreateVirtualReg(t1);
            fstate->LoadEffectiveAddress(t1, $2);

            X86Operand *ptr = new X86Operand(fstate, OP_TYPE::X86Mem,
                t1->AsX86Operand(fstate),         // base
                $4->AsX86Operand(fstate),         // index
                size,                             // element size
                0                                 // offset
            );
            $0->SetX86Operand(ptr);
            $0->SetSuffix(GetTypeSuffix(inst->getSourceElementType()));

            fstate->RecordLiveness(t1);
            fstate->RecordLiveness($2);
            fstate->RecordLiveness($4);
            $0->UseAsMemory();
            $0->UseAsPtr();
        };
ptr:    GetElementPtr(reg, imm, DUMMY)    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 5; } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);

            // get size of array elements
            using namespace llvm;
            GetElementPtrInst *inst = dyn_cast<GetElementPtrInst>($1->GetInst());
            assert(inst && "GetElementPtr must be not null");
            int size = GetTypeSize(inst->getSourceElementType());

            $action[2](fstate);
            $action[3](fstate);

            X86Operand *ptr = new X86Operand(fstate, OP_TYPE::X86Mem,
                $2->AsX86Operand(fstate),         // base
                0,
                0,
                size * $3->GetValue().val.i64s    // offset
            );
            $0->SetX86Operand(ptr);
            $0->SetSuffix(GetTypeSuffix(inst->getSourceElementType()));

            fstate->RecordLiveness($2);
            fstate->RecordLiveness($3);
            $0->UseAsMemory();
            $0->UseAsPtr();
        };
ptr:    GetElementPtr(reg, reg, DUMMY)    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 5; } = {
            if ($0->IsComputed()) return;
            // $0->SetComputed(true);

            // get size of array elements
            using namespace llvm;
            GetElementPtrInst *inst = dyn_cast<GetElementPtrInst>($1->GetInst());
            assert(inst && "GetElementPtr must be not null");
            int size = GetTypeSize(inst->getSourceElementType());

            $action[2](fstate);
            $action[3](fstate);

            X86Operand *ptr = new X86Operand(fstate, OP_TYPE::X86Mem,
                $2->AsX86Operand(fstate),         // base
                $3->AsX86Operand(fstate),         // index
                size,                             // element size
                0
            );
            $0->SetX86Operand(ptr);
            $0->SetSuffix(GetTypeSuffix(inst->getSourceElementType()));

            fstate->RecordLiveness($2);
            fstate->RecordLiveness($3);
            $0->UseAsMemory();
            $0->UseAsPtr();
        };
%%
#include "llc_olive_helper.cxx"
